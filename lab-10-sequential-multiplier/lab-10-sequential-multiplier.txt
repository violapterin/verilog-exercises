// sequential multiplier
// adapted from Mano and Ciletti, 6e, p 516




module multiplication(
   input clock, input clear,
   input [3:0] alpha, input [3:0] beta,
   output [3:0] anode, output [6:0] cathode
);
   wire [7:0] product;
   wire ready;
   multiplier the_multiplier(
        clock, clear,
        alpha, beta,
        product, ready
   );
   display the_display(
        clock, alpha, beta,
        product[7:4], product[3:0],
        anode, cathode
   );
endmodule




module multiplier(
   clock, clear,
   alpha, beta,
   product, ready
);
   parameter width = 4;
   input [width-1: 0] alpha, beta;
   input clock;
   input clear; // reset B
   output [2*width-1: 0] product;
   output ready;
   parameter state_idle = 3'b001; // S is idle
   parameter state_add = 3'b010; // S is idle
   parameter state_shift = 3'b100; // S is idle
   reg [2: 0] state, next;
   reg [width-1: 0] A, B, Q;
   reg C;
   reg [2: 0] P;
   reg flag_load, flag_decrease, flag_add, flag_shift;
   assign product = {A, Q};
   wire zero = (P == 0);
   wire ready = (state == state_idle);


   always @ (posedge clock, posedge clear) begin
        if (clear) state <= state_idle;
        else state <= next;
   end


   always @ (state, Q[0], zero) begin
        next = state_idle;
        flag_load = 0;
        flag_decrease = 0;
        flag_add = 0;
        flag_shift = 0;
        case (state)
          state_idle:
            if (clear) begin
               next = state_add;
               flag_load = 1;
            end
          state_add:
            begin
               next = state_shift;
               flag_decrease = 1;
               if (Q[0]) flag_add = 1;
            end
          state_shift:
            begin
               flag_shift = 1;
               if (zero) next = state_idle;
               else next = state_add;
            end
          default:
            next = state_idle;
        endcase
   end


   always @ (posedge clock) begin
        if (flag_load) begin
          P <= width;
          A <= 0;
          C <= 0;
          B <= alpha;
          Q <= beta;
        end
        if (flag_add) {C, A} <= A + B;
        if (flag_shift) {C, A, Q} <= {C, A, Q} >> 1;
        if (flag_decrease) P <= P - 1;
   end
endmodule


module display(
   input clock,
   input [3:0] digit_1, input [3:0] digit_2,
   input [3:0] digit_3, input [3:0] digit_4,
   output [3:0] anode, output [6:0] cathode
);
   wire enable;
   wire [1:0] choice;
   wire [6:0] decision;
   clock_enable the_clock_enable(clock, enable);
   anode_driver the_anode_driver(enable, choice, anode);
   mux the_mux(digit_1, digit_2, digit_3, digit_4, choice, decision);
   decoder the_decoder(decision, cathode);
endmodule


module clock_enable(
   input clock,
   output reg enable
);
   reg [16:0] count;
   initial begin
        count = 0;
        enable = 0;
   end
   always @(posedge clock) begin
        if(count == 8) begin
          count = 0;
          enable = 1;
        end
        else begin
          count = count + 1;
          enable = 0;
        end
   end
endmodule


module mux(
   input [3:0] digit_1, input [3:0] digit_2,
   input [3:0] digit_3, input [3:0] digit_4,
   input [1:0] choice,
   output reg [3:0] decision
);
   always @(*) begin
        case(choice)
          4'b00: decision = digit_1;
          4'b01: decision = digit_2;
          4'b10: decision = digit_3;
          4'b11: decision = digit_4;
        endcase
   end
endmodule


module anode_driver(
   input enable,
   output reg [1:0] choice, output reg [3:0] anode
);
   initial begin
        choice = 0;
        anode = 0;
   end
   always @(posedge enable) begin
        choice = choice + 1;
        case(choice)
          4'b00: anode = 4'b0111;
          4'b01: anode = 4'b1011;
          4'b10: anode = 4'b1101;
          4'b11: anode = 4'b1110;
        endcase
   end
endmodule


module decoder(input [3:0] decision, output reg [6:0] cathode);
   always @(*) begin
        case(decision)
          4'b0000: cathode = 7'b0000001;
          4'b0001: cathode = 7'b1001111;
          4'b0010: cathode = 7'b0010010;
          4'b0011: cathode = 7'b0000110;
   
          4'b0100: cathode = 7'b1001100;
          4'b0101: cathode = 7'b0100100;
          4'b0110: cathode = 7'b0100000;
          4'b0111: cathode = 7'b0001111;  


          4'b1000: cathode = 7'b0000000;
          4'b1001: cathode = 7'b0000100;
          4'b1010: cathode = 7'b0001000;
          4'b1011: cathode = 7'b1100000;


          4'b1100: cathode = 7'b0110001;
          4'b1101: cathode = 7'b1000010;
          4'b1110: cathode = 7'b0110000;
          4'b1111: cathode = 7'b0111000;
        endcase
   end
endmodule




// // // // // // // // // // // // // // // //


set_property PACKAGE_PIN W5 [get_ports clock]
set_property PACKAGE_PIN T18 [get_ports clear]


set_property PACKAGE_PIN R2 [get_ports {alpha[3]}]
set_property PACKAGE_PIN T1 [get_ports {alpha[2]}]
set_property PACKAGE_PIN U1 [get_ports {alpha[1]}]
set_property PACKAGE_PIN W2 [get_ports {alpha[0]}]
set_property PACKAGE_PIN R3 [get_ports {beta[3]}]
set_property PACKAGE_PIN T2 [get_ports {beta[2]}]
set_property PACKAGE_PIN T3 [get_ports {beta[1]}]
set_property PACKAGE_PIN V2 [get_ports {beta[0]}]


set_property PACKAGE_PIN W4 [get_ports {anode[3]}]
set_property PACKAGE_PIN V4 [get_ports {anode[2]}]
set_property PACKAGE_PIN U4 [get_ports {anode[1]}]
set_property PACKAGE_PIN U2 [get_ports {anode[0]}]
set_property PACKAGE_PIN U7 [get_ports {cathode[0]}]
set_property PACKAGE_PIN V5 [get_ports {cathode[1]}]
set_property PACKAGE_PIN U5 [get_ports {cathode[2]}]
set_property PACKAGE_PIN V8 [get_ports {cathode[3]}]
set_property PACKAGE_PIN U8 [get_ports {cathode[4]}]
set_property PACKAGE_PIN W6 [get_ports {cathode[5]}]
set_property PACKAGE_PIN W7 [get_ports {cathode[6]}]


set_property IOSTANDARD LVCMOS18 [get_ports clock]
set_property IOSTANDARD LVCMOS18 [get_ports clear]


set_property IOSTANDARD LVCMOS18 [get_ports {alpha[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {alpha[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {alpha[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {alpha[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {beta[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {beta[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {beta[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {beta[0]}]


set_property IOSTANDARD LVCMOS18 [get_ports {anode[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {anode[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {anode[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {anode[0]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[6]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[5]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[4]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[3]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[2]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[1]}]
set_property IOSTANDARD LVCMOS18 [get_ports {cathode[0]}]